// Generated by CoffeeScript 1.6.3
/*
Kaliedoscope Test

http://stackoverflow.com/questions/13739901/vertex-kaleidoscope-shader
*/


(function() {
  var Kaliedoscope, canvas, cgl, kk,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Kaliedoscope = (function() {
    function Kaliedoscope() {
      this.resize = __bind(this.resize, this);
    }

    Kaliedoscope.prototype.loadAssets = function() {
      var a, b, i, self, _genLoadAudio, _i, _j, _loadVideo;
      a = function() {
        return console.log("Loaded: " + this.completed_items.length / this.items.length);
      };
      b = function() {
        return console.log("Loaded All");
      };
      this.lq = new CoffeeGL.Loader.LoadQueue(this, a, b);
      self = this;
      _loadVideo = new CoffeeGL.Loader.LoadItem(function() {
        var _this = this;
        self.video_element = document.getElementById("video");
        self.video_element.preload = "auto";
        self.video_element.src = "/background.mp4";
        self.video_element.addEventListener("ended", function() {
          self.video_element.currentTime = 0;
          return self.video_element.play();
        }, false);
        self.video_element.addEventListener("timeupdate", function() {
          if (self.video_element.currentTime > 53) {
            self.video_element.pause();
            self.video_element.currentTime = 0;
            self.video_element.play();
          }
        }, false);
        return self.video_element.oncanplay = function(event) {
          if (!self.video_ready) {
            self.video_element.play();
            self.t.update(self.video_element);
            self.video_node.add(self.t);
            self.video_ready = true;
            _this.loaded();
            return console.log("Video Loaded");
          }
        };
      });
      _genLoadAudio = function(audio_url, attach, long) {
        var _loadAudioSample;
        return _loadAudioSample = new CoffeeGL.Loader.LoadItem(function() {
          var sound,
            _this = this;
          sound = new Howl({
            urls: [audio_url],
            onload: function() {
              attach.push(sound);
              sound.playing = false;
              return _this.loaded();
            },
            onplay: function() {
              this.playing = true;
              if (long) {
                return self.sound_long_playing = true;
              }
            },
            onend: function() {
              this.playing = false;
              if (long) {
                return self.sound_long_playing = false;
              }
            }
          });
          return _loadAudioSample;
        });
      };
      this.lq.add(_loadVideo);
      for (i = _i = 0; _i <= 9; i = ++_i) {
        this.lq.add(_genLoadAudio('/sound/long/sound00' + i + '.mp3', this.sounds_long, true));
      }
      for (i = _j = 0; _j <= 9; i = ++_j) {
        this.lq.add(_genLoadAudio('/sound/short/sound00' + i + '.mp3', this.sounds_short, false));
      }
      return this.lq.start();
    };

    Kaliedoscope;

    Kaliedoscope.prototype.playSound = function() {
      var _ref, _ref1;
      if (_ref = this.selected_tris, __indexOf.call(this.sound_long_triggers, _ref) >= 0) {
        if (!this.sound_long_playing) {
          this.sounds_long[Math.floor(Math.random() * this.sounds_long.length)].play();
        }
      }
      if (this.selected_tris !== this.selected_tris_prev) {
        if (_ref1 = this.selected_tris, __indexOf.call(this.sound_short_triggers, _ref1) >= 0) {
          return this.sounds_short[Math.floor(Math.random() * this.sounds_short.length)].play();
        }
      }
    };

    Kaliedoscope.prototype.setupPlane = function() {
      var i, idc, ids, idt, j, sstep, tcs, _i, _j, _k, _ref, _ref1;
      this.plane = new CoffeeGL.PlaneHexagonFlat(this.plane_xres, this.plane_yres);
      idt = 0;
      idc = 0;
      tcs = [
        {
          u: 0.0,
          v: 0.0
        }, {
          u: 0.5,
          v: 1.0
        }, {
          u: 1.0,
          v: 0.0
        }
      ];
      sstep = [0, 1, 2];
      ids = 0;
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        ids = 0;
        for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.plane.t[idt++] = tcs[ids].u;
          this.plane.t[idt++] = tcs[ids].v;
          ids++;
          if (ids > 2) {
            ids = 0;
          }
          for (i = _k = 0; _k <= 3; i = ++_k) {
            this.plane.c[idc++] = 0;
          }
        }
      }
      return this.plane_base = JSON.parse(JSON.stringify(this.plane));
    };

    Kaliedoscope.prototype.rotateTexCoords = function() {
      var i, idt, j, np, rotm, _i, _ref, _results;
      np = new CoffeeGL.Vec3(0, 0, 0);
      idt = 0;
      rotm = new CoffeeGL.Matrix4();
      rotm.rotate(new CoffeeGL.Vec3(0, 0, 1), 0.001 * this.warp.rot_speed);
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            np.x = (this.plane.t[idt] * 2.0) - 1;
            np.y = (this.plane.t[idt + 1] * 2.0) - 1;
            rotm.multVec(np);
            this.plane.t[idt++] = (np.x + 1) / 2;
            _results1.push(this.plane.t[idt++] = (np.y + 1) / 2);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.morphPlane = function() {
      var dd, force, force_dist, i, idc, idt, inv, j, np, _i, _j, _ref, _ref1;
      if (!(this.mouse_over && this.mouse_pressed)) {
        return;
      }
      idt = 0;
      idc = 0;
      np = new CoffeeGL.Vec3(0, 0, 0);
      inv = CoffeeGL.Matrix4.invert(this.video_node.matrix);
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          np.x = this.plane.p[idt++];
          np.y = this.plane.p[idt++];
          np.z = this.plane.p[idt++];
          this.video_node.matrix.multVec(np);
          force = CoffeeGL.Vec3.sub(this.intersect, this.intersect_prev);
          force_dist = this.intersect.dist(this.intersect_prev);
          dd = np.dist(this.intersect);
          if (force_dist > 0.01) {
            if (dd < this.warp.range) {
              force.normalize();
              force.multScalar(this.warp.force * 1.0 / Math.pow(dd, this.warp.exponent));
              np.x = force.x;
              np.y = force.y;
              np.z = 0;
              inv.multVec(np);
              this.plane.c[idc] += np.x;
              this.plane.c[idc + 1] += np.y;
              this.plane.c[idc + 2] += np.z;
              this.plane.c[idc + 3] = 0;
            }
          }
          idc += 4;
        }
      }
      return this;
    };

    Kaliedoscope.prototype.springBack = function() {
      var bp, ff, i, idc, idt, j, np, spring_dist, spring_force, _i, _ref, _results;
      idt = 0;
      idc = 0;
      np = new CoffeeGL.Vec3(0, 0, 0);
      bp = new CoffeeGL.Vec3(0, 0, 0);
      ff = new CoffeeGL.Vec3(0, 0, 0);
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            np.x = this.plane.p[idt];
            np.y = this.plane.p[idt + 1];
            np.z = this.plane.p[idt + 2];
            bp.x = this.plane_base.p[idt];
            bp.y = this.plane_base.p[idt + 1];
            bp.z = this.plane_base.p[idt + 2];
            ff.x = this.plane.c[idc];
            ff.y = this.plane.c[idc + 1];
            ff.z = this.plane.c[idc + 2];
            spring_force = CoffeeGL.Vec3.sub(bp, np);
            spring_dist = bp.dist(np);
            spring_force.normalize();
            spring_force.multScalar(spring_dist * this.warp.springiness);
            ff.add(spring_force);
            ff.multScalar(this.warp.spring_damping);
            this.plane.c[idc] = ff.x;
            this.plane.c[idc + 1] = ff.y;
            this.plane.c[idc + 2] = ff.z;
            this.plane.p[idt] = np.x + ff.x;
            this.plane.p[idt + 1] = np.y + ff.y;
            this.plane.p[idt + 2] = np.z + ff.z;
            idt += 3;
            _results1.push(idc += 4);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.videoNodeTrans = function(w, h) {
      var xfactor, yfactor;
      if (w == null) {
        w = 1;
      }
      if (h == null) {
        h = 1;
      }
      this.video_node.matrix.identity();
      this.video_node.matrix.rotate(new CoffeeGL.Vec3(1, 0, 0), CoffeeGL.PI / 2);
      xfactor = 2.0 * w / h;
      yfactor = 2.0;
      return this.video_node.matrix.scale(new CoffeeGL.Vec3(xfactor, 1, yfactor));
    };

    Kaliedoscope.prototype.init = function() {
      var datg, i, r0, _i, _j,
        _this = this;
      this.plane_yres = 9;
      this.plane_xres = 21;
      this.setupPlane();
      this.video_node = new CoffeeGL.Node(this.plane);
      this.ray = new CoffeeGL.Vec3(0, 0, 0);
      this.intersect_prev = new CoffeeGL.Vec3(0, 0, 0);
      this.intersect = new CoffeeGL.Vec3(0, 0, 0);
      this.selected_tris = this.selected_tris_prev = -1;
      this.warp = {
        exponent: 1.4,
        force: 0.001,
        range: 1.0,
        falloff_factor: 1.0,
        springiness: 0.005,
        springiness_exponent: 2.0,
        rot_speed: 4.0,
        spring_damping: 0.92
      };
      this.sound_long_playing = false;
      this.sound_on = false;
      this.sound_long_triggers = [];
      this.sound_short_triggers = [];
      for (i = _i = 0; _i <= 55; i = ++_i) {
        this.sound_long_triggers.push(Math.floor(Math.random() * this.plane.getNumTris()));
      }
      for (i = _j = 0; _j <= 100; i = ++_j) {
        this.sound_short_triggers.push(Math.floor(Math.random() * this.plane.getNumTris()));
      }
      this.video_node.brew({
        position_buffer_access: GL.DYNAMIC_DRAW,
        texcoord_buffer_access: GL.DYNAMIC_DRAW
      });
      this.videoNodeTrans(CoffeeGL.Context.width, CoffeeGL.Context.height);
      r0 = new CoffeeGL.Request('/basic_texture.glsl');
      r0.get(function(data) {
        _this.shader = new CoffeeGL.Shader(data);
        _this.shader.bind();
        return _this.shader.setUniform3v("uMouseRay", new CoffeeGL.Vec3(0, 0, 0));
      });
      this.camera = new CoffeeGL.Camera.PerspCamera();
      this.camera.pos.z = 3.8;
      this.camera.setViewport(CoffeeGL.Context.width, CoffeeGL.Context.height);
      this.video_node.add(this.camera);
      this.t = new CoffeeGL.TextureBase({
        width: 240,
        height: 134
      });
      GL.enable(GL.CULL_FACE);
      GL.cullFace(GL.BACK);
      GL.enable(GL.DEPTH_TEST);
      this.video_ready = false;
      this.sounds_long = [];
      this.sounds_short = [];
      this.loadAssets();
      datg = new dat.GUI();
      datg.remember(this);
      datg.add(this.warp, 'exponent', 1.0, 5.0);
      datg.add(this.warp, 'force', 0.0001, 0.01);
      datg.add(this.warp, 'range', 0.1, 5.0);
      datg.add(this.warp, 'springiness', 0.0001, 0.01);
      datg.add(this.warp, 'spring_damping', 0.1, 1.0);
      datg.add(this.warp, 'rot_speed', 0.01, 10.0);
      datg.add(this, 'sound_on');
      CoffeeGL.Context.mouseMove.add(this.mouseMoved, this);
      CoffeeGL.Context.mouseOut.add(this.mouseOut, this);
      CoffeeGL.Context.mouseOver.add(this.mouseOver, this);
      CoffeeGL.Context.mouseDown.add(this.mouseDown, this);
      CoffeeGL.Context.mouseUp.add(this.mouseUp, this);
      this.mouse_over = false;
      return this.mouse_pressed = false;
    };

    Kaliedoscope.prototype.update = function(dt) {
      if (this.video_ready) {
        this.t.update(this.video_element);
      }
      if (this.shader != null) {
        this.shader.setUniform1f("uClockTick", CoffeeGL.Context.contextTime);
      }
      this.morphPlane();
      this.video_node.rebrew({
        position_buffer: 0,
        texcoord_buffer: 0
      });
      this.springBack();
      if (this.sound_on) {
        return this.playSound();
      }
    };

    Kaliedoscope.prototype.draw = function() {
      GL.clearColor(0.15, 0.15, 0.15, 1.0);
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
      return this.video_node.draw();
    };

    Kaliedoscope.prototype.resize = function() {
      CoffeeGL.Context.resizeCanvas(window.innerWidth, window.innerHeight);
      this.camera.setViewport(CoffeeGL.Context.width, CoffeeGL.Context.height);
      return this.videoNodeTrans(CoffeeGL.Context.width, CoffeeGL.Context.height);
    };

    Kaliedoscope.prototype.mouseMoved = function(event) {
      var x, y;
      x = event.mouseX;
      y = event.mouseY;
      this.intersect_prev.copyFrom(this.intersect);
      this.rotateTexCoords();
      this.intersect.set(0, 0, 0);
      this.selected_tris_prev = this.selected_tris;
      this.selected_tris = CoffeeGL.Math.screenNodeHitTest(x, y, this.camera, this.video_node, this.intersect);
      if (this.selected_tris !== -1) {
        if (this.shader != null) {
          this.shader.setUniform1f("uHighLight", 1.0);
        }
      } else {
        if (this.shader != null) {
          this.shader.setUniform1f("uHighLight", 0.0);
        }
      }
      if (this.shader != null) {
        return this.shader.setUniform3v("uMousePos", this.intersect);
      }
    };

    Kaliedoscope.prototype.mouseOver = function(event) {
      return this.mouse_over = true;
    };

    Kaliedoscope.prototype.mouseOut = function(event) {
      return this.mouse_over = false;
    };

    Kaliedoscope.prototype.mouseDown = function(event) {
      return this.mouse_pressed = true;
    };

    Kaliedoscope.prototype.mouseUp = function(event) {
      this.mouse_pressed = false;
      this.intersect_prev.set(0, 0, 0);
      return this.intersect.set(0, 0, 0);
    };

    return Kaliedoscope;

  })();

  canvas = document.getElementById('webgl-canvas');

  canvas.width = window.innerWidth;

  canvas.height = window.innerHeight;

  kk = new Kaliedoscope();

  cgl = new CoffeeGL.App('webgl-canvas', kk, kk.init, kk.draw, kk.update);

  if (typeof window !== "undefined" && window !== null) {
    window.addEventListener('resize', kk.resize, false);
  }

}).call(this);

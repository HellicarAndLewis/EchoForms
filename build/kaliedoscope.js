// Generated by CoffeeScript 1.6.3
/*
Echo Forms - Hellicar & Lewis
Coding - Benjamin Blundell @ section9.co.uk


http://stackoverflow.com/questions/13739901/vertex-kaleidoscope-shader
*/


(function() {
  var Kaliedoscope, QueryString, canvas, credits_resize, flowx, flowy, gridx, gridy, item, kaliedoscopeWebGL, keypressed, kk, loadAssets, params, url_vars,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  loadAssets = require('./assets').loadAssets;

  Kaliedoscope = (function() {
    function Kaliedoscope(plane_xres, plane_yres, flow_xres, flow_yres) {
      this.plane_xres = plane_xres;
      this.plane_yres = plane_yres;
      this.flow_xres = flow_xres;
      this.flow_yres = flow_yres;
      this.resize = __bind(this.resize, this);
      this.state = {
        startup: true,
        loaded: false,
        webcam: false,
        video: false,
        youtube: false,
        youtube_fetch: false,
        num_shaders: 0,
        shaders: false
      };
      this;
    }

    Kaliedoscope.prototype.playSound = function() {
      var _ref;
      if (this.selected_tris !== this.selected_tris_prev) {
        if (_ref = this.selected_tris, __indexOf.call(this.sound_short_triggers, _ref) >= 0) {
          return this.sounds_short[Math.floor(Math.random() * this.sounds_short.length)].play();
        }
      }
    };

    Kaliedoscope.prototype.setupPlane = function() {
      var i, idc, idp, ids, idt, j, k, sstep, tcs, tx, ty, _i, _j, _k, _l, _ref, _ref1, _ref2, _results;
      this.plane = new CoffeeGL.PlaneHexagonFlat(this.plane_xres, this.plane_yres);
      this.plane_face = new CoffeeGL.PlaneHexagonFlat(this.plane_xres, this.plane_yres, false);
      idt = 0;
      idp = 0;
      idc = 0;
      tcs = [
        {
          u: 0.0,
          v: 0.0
        }, {
          u: 0.5,
          v: 1.0
        }, {
          u: 1.0,
          v: 0.0
        }
      ];
      sstep = [0, 1, 2];
      ids = 0;
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        ids = 0;
        for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          tx = 2.0 * Math.random() - 1;
          ty = 2.0 * Math.random() - 1;
          this.plane.t[idt++] = tcs[ids].u + (this.noise.simplex2(tx, ty) * 0.25);
          this.plane.t[idt++] = tcs[ids].v + (this.noise.simplex2(tx, ty) * 0.25);
          this.plane.p[idp++] += this.noise.simplex2(tx, ty) * 0.02;
          idp++;
          this.plane.p[idp++] += this.noise.simplex2(tx, ty) * 0.02;
          ids++;
          if (ids > 2) {
            ids = 0;
          }
          for (i = _k = 0; _k <= 3; i = ++_k) {
            this.plane.c[idc++] = 0;
          }
        }
      }
      this.plane_base = JSON.parse(JSON.stringify(this.plane));
      idc = 0;
      _results = [];
      for (i = _l = 0, _ref2 = this.plane_yres - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        _results.push((function() {
          var _m, _n, _ref3, _results1;
          _results1 = [];
          for (j = _m = 0, _ref3 = this.plane_xres - 1; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; j = 0 <= _ref3 ? ++_m : --_m) {
            for (k = _n = 0; _n <= 11; k = ++_n) {
              this.plane_face.c[idc * 12 + k] = 0;
            }
            _results1.push(idc++);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.rotateTexCoords = function() {
      var i, idt, j, noize, np, rotm, tx, ty, _i, _ref, _results;
      np = new CoffeeGL.Vec3(0, 0, 0);
      idt = 0;
      rotm = new CoffeeGL.Matrix4();
      rotm.rotate(new CoffeeGL.Vec3(0, 0, 1), 0.001 * this.warp.rot_speed);
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            tx = (Math.random() * 2.0 - 1) * 0.1;
            ty = (Math.random() * 2.0 - 1) * 0.1;
            noize = this.noise.simplex2(this.intersect.x + tx, this.intersect.y + ty);
            np.x = (this.plane.t[idt] * 2.0) - 1;
            np.y = (this.plane.t[idt + 1] * 2.0) - 1;
            rotm.multVec(np);
            this.plane.t[idt++] = (np.x + 1) / 2;
            _results1.push(this.plane.t[idt++] = (np.y + 1) / 2);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.naturalForce = function() {
      var i, idc, idt, j, noize, np, _i, _ref, _results;
      np = new CoffeeGL.Vec3(0, 0, 0);
      idt = 0;
      idc = 0;
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            if (Math.random() > this.warp.natural_rate) {
              np.x = this.plane.p[idt++];
              np.y = this.plane.p[idt++];
              np.z = this.plane.p[idt++];
              noize = this.noise.simplex2(np.x * 1.5, np.y * 1.5);
              this.plane.c[idc + 1] += noize * this.warp.natural_force;
            }
            _results1.push(idc += 4);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.morphPlane = function(intersect, intersect_prev) {
      var dd, force, force_dist, i, idc, idt, inv, j, np, _i, _j, _ref, _ref1;
      idt = 0;
      idc = 0;
      np = new CoffeeGL.Vec3(0, 0, 0);
      inv = CoffeeGL.Matrix4.invert(this.video_node.matrix);
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          np.x = this.plane.p[idt++];
          np.y = this.plane.p[idt++];
          np.z = this.plane.p[idt++];
          this.video_node.matrix.multVec(np);
          force = CoffeeGL.Vec3.sub(intersect, intersect_prev);
          force_dist = intersect.dist(intersect_prev);
          dd = np.dist(intersect);
          if (force_dist > 0.01) {
            if (dd < this.warp.range) {
              force.normalize();
              force.multScalar(this.warp.force * 1.0 / Math.pow(dd, this.warp.exponent));
              np.x = force.x;
              np.y = force.y;
              np.z = 0;
              inv.multVec(np);
              this.plane.c[idc] += np.x;
              this.plane.c[idc + 1] += np.y;
              this.plane.c[idc + 2] += np.z;
              this.plane.c[idc + 3] = 0;
            }
          }
          idc += 4;
        }
      }
      return this;
    };

    Kaliedoscope.prototype.springBack = function() {
      var bp, ff, i, idc, idt, j, np, spring_dist, spring_force, _i, _ref, _results;
      idt = 0;
      idc = 0;
      np = new CoffeeGL.Vec3(0, 0, 0);
      bp = new CoffeeGL.Vec3(0, 0, 0);
      ff = new CoffeeGL.Vec3(0, 0, 0);
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            np.x = this.plane.p[idt];
            np.y = this.plane.p[idt + 1];
            np.z = this.plane.p[idt + 2];
            bp.x = this.plane_base.p[idt];
            bp.y = this.plane_base.p[idt + 1];
            bp.z = this.plane_base.p[idt + 2];
            ff.x = this.plane.c[idc];
            ff.y = this.plane.c[idc + 1];
            ff.z = this.plane.c[idc + 2];
            spring_force = CoffeeGL.Vec3.sub(bp, np);
            spring_dist = bp.dist(np);
            spring_force.normalize();
            spring_force.multScalar(spring_dist * this.warp.springiness);
            ff.add(spring_force);
            ff.multScalar(this.warp.spring_damping);
            this.plane.c[idc] = ff.x;
            this.plane.c[idc + 1] = ff.y;
            this.plane.c[idc + 2] = ff.z;
            this.plane.p[idt] = np.x + ff.x;
            this.plane.p[idt + 1] = np.y + ff.y;
            this.plane.p[idt + 2] = np.z + ff.z;
            idt += 3;
            _results1.push(idc += 4);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.copyToFace = function() {
      var i, idp, idx, j, _i, _ref, _results;
      idp = 0;
      _results = [];
      for (i = _i = 0, _ref = this.plane.indices.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        idx = this.plane.indices[i];
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = 0; _j <= 2; j = ++_j) {
            _results1.push(this.plane_face.p[idp++] = this.plane.p[idx * 3 + j]);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.geomTrans = function(w, h) {
      var xfactor, yfactor;
      if (w == null) {
        w = 1;
      }
      if (h == null) {
        h = 1;
      }
      this.video_node.matrix.identity();
      this.video_node.matrix.rotate(new CoffeeGL.Vec3(1, 0, 0), CoffeeGL.PI / 2);
      xfactor = 2.0 * w / h;
      yfactor = 2.0;
      this.video_node.matrix.scale(new CoffeeGL.Vec3(xfactor, 1, yfactor));
      return this.face_node.matrix.copyFrom(this.video_node.matrix);
    };

    Kaliedoscope.prototype.init = function() {
      var i, r2, r3, r4, _i,
        _this = this;
      this.loading_items = [];
      this.loading_timeout = 0;
      this.ready_fade_in = 0;
      this.loading_time_limit = 3;
      this.ready_fade_time = 3;
      this.noise = new CoffeeGL.Noise.Noise();
      this.noise.setSeed(Math.random());
      if (this.colour_palette == null) {
        this.colour_palette = [new CoffeeGL.Colour.RGBA(254, 67, 101), new CoffeeGL.Colour.RGBA(252, 157, 154), new CoffeeGL.Colour.RGBA(249, 205, 173), new CoffeeGL.Colour.RGBA(200, 200, 169), new CoffeeGL.Colour.RGBA(131, 175, 155)];
      }
      this.setupPlane();
      this.video_node = new CoffeeGL.Node(this.plane);
      this.face_node = new CoffeeGL.Node(this.plane_face);
      this.video_node.brew({
        position_buffer_access: GL.DYNAMIC_DRAW,
        texcoord_buffer_access: GL.DYNAMIC_DRAW
      });
      this.face_node.brew({
        position_buffer_access: GL.DYNAMIC_DRAW,
        colour_buffer_access: GL.DYNAMIC_DRAW
      });
      this.geomTrans(CoffeeGL.Context.width, CoffeeGL.Context.height);
      this.webcam_node_draw = false;
      this.webcam_node = new CoffeeGL.Node(new CoffeeGL.Quad());
      r2 = new CoffeeGL.Request('/kaliedoscope.glsl');
      r2.get(function(data) {
        _this.shader = new CoffeeGL.Shader(data);
        _this.state["num_shaders"] += 1;
        if (_this.state["num_shaders"] === 3) {
          return _this.state["shaders"] = true;
        }
      });
      r4 = new CoffeeGL.Request('/basic_texture.glsl');
      r4.get(function(data) {
        _this.shader_basic = new CoffeeGL.Shader(data);
        _this.state["num_shaders"] += 1;
        if (_this.state["num_shaders"] === 3) {
          return _this.state["shaders"] = true;
        }
      });
      r3 = new CoffeeGL.Request('/face.glsl');
      r3.get(function(data) {
        _this.shader_face = new CoffeeGL.Shader(data);
        _this.shader_face.bind();
        _this.shader_face.setUniform1f("uAlphaScalar", _this.highLight.alpha_scalar);
        _this.state["num_shaders"] += 1;
        if (_this.state["num_shaders"] === 3) {
          return _this.state["shaders"] = true;
        }
      });
      this.ray = new CoffeeGL.Vec3(0, 0, 0);
      this.intersect_prev = new CoffeeGL.Vec3(0, 0, 0);
      this.intersect = new CoffeeGL.Vec3(0, 0, 0);
      this.selected_tris = this.selected_tris_prev = -1;
      this.intersect_prev_optical = new CoffeeGL.Vec3(0, 0, 0);
      this.intersect_optical = new CoffeeGL.Vec3(0, 0, 0);
      this.warp = {
        exponent: 2,
        force: 0.0012 + (Math.random() * 0.001),
        range: 1.0 + (Math.random() * 0.5),
        falloff_factor: 1.0,
        springiness: 0.065 + (Math.random() * 0.01),
        springiness_exponent: 2.0,
        rot_speed: 4.0,
        spring_damping: 0.77 + (Math.random() * 0.15),
        natural_rate: 0.9,
        natural_force: 0.002
      };
      this.highLight = {
        speed_in: 0.1 + (-0.01 + Math.random() * 0.02),
        speed_out: 0.009 + (Math.random() * 0.01),
        alpha_scalar: 0.24 + (Math.random() * 0.01)
      };
      this.webcam_params = {
        fader: 0.0,
        fade_duration: 3.0,
        fade_current_duration: 0,
        fade_target: 0,
        fade_time: 60.0,
        fade_current_time: 0
      };
      this.sound_long_playing = false;
      this.sound_on = false;
      this.sound_short_triggers = [];
      if (!this.state["loaded"]) {
        this.sounds_long = [];
        this.sounds_short = [];
      }
      for (i = _i = 0; _i <= 100; i = ++_i) {
        this.sound_short_triggers.push(Math.floor(Math.random() * this.plane.getNumTris()));
      }
      this.camera = new CoffeeGL.Camera.PerspCamera();
      this.camera.pos.z = 3.8;
      this.camera.near = 0.001;
      this.camera.far = 8.0;
      this.camera.setViewport(CoffeeGL.Context.width, CoffeeGL.Context.height);
      this.video_node.add(this.camera);
      this.face_node.add(this.camera);
      this.webcam_node.add(this.camera);
      this.t = new CoffeeGL.TextureBase({
        width: 256,
        height: 256
      });
      GL.enable(GL.BLEND);
      GL.blendFunc(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA);
      if (this.video_ready == null) {
        this.video_ready = false;
      } else {
        this.video_element.play();
        this.video_node.add(this.t);
      }
      if (!this.state["loaded"]) {
        loadAssets(this);
      }
      /*
      @datg = new dat.GUI()
      @datg.remember(@)
      
      @datg.add(@warp,'exponent',1.0,5.0)
      @datg.add(@warp,'force',0.0001,0.01)
      @datg.add(@warp,'range',0.1,5.0)
      @datg.add(@warp,'springiness', 0.0001, 0.1).step(0.0001)
      @datg.add(@warp,'spring_damping', 0.1, 1.0).step(0.001)
      @datg.add(@warp,'rot_speed', 0.01, 10.0)
      @datg.add(@warp,'natural_rate', 0.1, 1.0)
      @datg.add(@warp,'natural_force', 0.0001, 0.01)
      @datg.add(@,'sound_on')
      @datg.add(@highLight,'speed_in', 0.001, 0.1)
      @datg.add(@highLight,'speed_out', 0.001, 0.1)
      @datg.add(@highLight, 'alpha_scalar',0.1,1.0)
      @datg.add(@webcam_params, 'fader', 0.0, 1.0).step(0.01)
      @datg.add(@webcam_params, 'fade_time', 0, 600).step(1)
      @datg.add(@webcam_params, 'fade_duration', 0, 10).step(0.1)
      */

      this.youtube_element = document.getElementById("video_youtube");
      CoffeeGL.Context.mouseMove.add(this.mouseMoved, this);
      CoffeeGL.Context.mouseOut.add(this.mouseOut, this);
      CoffeeGL.Context.mouseOver.add(this.mouseOver, this);
      CoffeeGL.Context.mouseDown.add(this.mouseDown, this);
      CoffeeGL.Context.mouseUp.add(this.mouseUp, this);
      this.mouse_over = false;
      return this.mouse_pressed = false;
    };

    Kaliedoscope.prototype.submitYouTube = function(url) {
      var textbox, youtube_id,
        _this = this;
      if (this.state["youtube_fetch"]) {
        return;
      }
      this.state["youtube_fetch"] = true;
      this.state["youtube"] = false;
      youtube_id = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/i);
      if (youtube_id == null) {
        alert("Youtube Link is incorrect.");
        this.state["youtube_fetch"] = false;
        textbox = document.getElementById("youtube-textbox");
        $('#submit-button').button('reset');
        return;
      }
      this.youtube_element.src = 'https://dejima.section9.co.uk/youtube?id=' + encodeURIComponent(youtube_id[0]);
      this.youtube_element.addEventListener("ended", function() {
        this.youtube_element.currentTime = 0;
        return this.youtube_element.play();
      }, false);
      return this.youtube_element.oncanplay = function(event) {
        var credits;
        _this.t = new CoffeeGL.TextureBase({
          width: _this.youtube_element.videoWidth,
          height: _this.youtube_element.videoHeight
        });
        _this.video_node.add(_this.t);
        _this.youtube_element.play();
        _this.t.update(_this.youtube_element);
        _this.state["youtube"] = true;
        _this.state["youtube_fetch"] = false;
        credits = document.getElementById('credits');
        return credits.style.display = 'none';
      };
    };

    Kaliedoscope.prototype.updateFaceHighlight = function(idx) {
      var i, idc, j, k, _i, _ref, _results;
      idc = 0;
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _k, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            for (k = _k = 0; _k <= 11; k = ++_k) {
              if (idx === idc) {
                this.plane_face.c[idc * 12 + k] += this.highLight.speed_in;
              } else {
                this.plane_face.c[idc * 12 + k] -= this.highLight.speed_out;
              }
              if (this.plane_face.c[idc * 12 + k] <= 0) {
                this.plane_face.c[idc * 12 + k] = 0;
              }
              if (this.plane_face.c[idc * 12 + k] >= 1.0) {
                this.plane_face.c[idc * 12 + k] = 1.0;
              }
            }
            _results1.push(idc++);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.updateFaceColour = function(idx, colour) {
      var i, idc, j, k, _i, _ref, _results;
      idc = 0;
      _results = [];
      for (i = _i = 0, _ref = this.plane_yres - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _k, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.plane_xres - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            for (k = _k = 0; _k <= 2; k = ++_k) {
              if (idx === idc) {
                this.plane_face.c[idc * 12 + (k * 4)] = colour.r;
                this.plane_face.c[idc * 12 + (k * 4) + 1] = colour.g;
                this.plane_face.c[idc * 12 + (k * 4) + 2] = colour.b;
                this.plane_face.c[idc * 12 + (k * 4) + 3] = colour.a;
              }
            }
            _results1.push(idc++);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Kaliedoscope.prototype.updateLoading = function(dt) {
      var i, tc, tt, _i, _len, _ref;
      this.shader_face.bind();
      this.shader_face.setUniform1f("uClockTick", CoffeeGL.Context.contextTime);
      this.shader_face.setUniform1f("uAlphaScalar", 1.0);
      _ref = this.loading_items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        tc = i.colour;
        tt = i.target;
        if (tc.r < tt.r) {
          tc.r += this.highLight.speed_in * tt.r;
        }
        if (tc.g < tt.g) {
          tc.g += this.highLight.speed_in * tt.g;
        }
        if (tc.b < tt.b) {
          tc.b += this.highLight.speed_in * tt.b;
        }
        if (tc.a < tt.a) {
          tc.a += this.highLight.speed_in * tt.a;
        }
        this.updateFaceColour(i.idx, tc);
      }
      this.naturalForce();
      this.copyToFace();
      this.springBack();
      return this.face_node.rebrew({
        position_buffer: 0,
        colour_buffer: 0
      });
    };

    Kaliedoscope.prototype.updateFader = function(dt) {
      if (this.webcam_params.fade_current_time >= this.webcam_params.fade_time) {
        console.log("UPDATE");
        if (this.webcam_params.fade_current_duration === 0) {
          if (this.webcam_params.fader >= 0.5) {
            this.webcam_params.fade_target = 0.0;
          } else {
            this.webcam_params.fade_target = 1.0;
          }
          this.webcam_params.tween = new CoffeeGL.Interpolation(this.webcam_params.fader, this.webcam_params.fade_target);
          console.log(this.webcam_params.fader);
        }
        this.webcam_params.fade_current_duration += dt / 1000;
        this.webcam_params.fader = this.webcam_params.tween.set(this.webcam_params.fade_current_duration / this.webcam_params.fade_duration);
        if (this.webcam_params.fade_current_duration >= this.webcam_params.fade_duration) {
          this.webcam_params.fade_current_time = 0;
          this.webcam_params.fade_dist = 0;
          return this.webcam_params.fade_current_duration = 0;
        }
      }
    };

    Kaliedoscope.prototype.updateWebcam = function(dt) {
      var active_flow, cur_now, cx, cy, dd, i, max_diff, max_now, now, prev, prev_now, px, py, _i, _len;
      this.wt.update(this.webcam_element);
      this.optical_flow.update(dt);
      active_flow = this.optical_flow.active_intersections();
      max_diff = 0;
      max_now = new CoffeeGL.Vec2(0, 0);
      cur_now = new CoffeeGL.Vec2(0, 0);
      prev_now = new CoffeeGL.Vec2(0, 0);
      for (_i = 0, _len = active_flow.length; _i < _len; _i++) {
        i = active_flow[_i];
        now = i[0];
        prev = i[1];
        now[0] = this.webcam_element.videoWidth - now[0];
        prev[0] = this.webcam_element.videoWidth - prev[0];
        px = prev[0] / this.webcam_element.videoWidth * CoffeeGL.Context.width;
        py = prev[1] / this.webcam_element.videoHeight * CoffeeGL.Context.height;
        cx = now[0] / this.webcam_element.videoWidth * CoffeeGL.Context.width;
        cy = now[1] / this.webcam_element.videoHeight * CoffeeGL.Context.height;
        CoffeeGL.Math.screenNodeHitTest(px, py, this.camera, this.video_node, this.intersect_prev_optical);
        CoffeeGL.Math.screenNodeHitTest(cx, cy, this.camera, this.video_node, this.intersect_optical);
        this.morphPlane(this.intersect_optical, this.intersect_prev_optical);
        cur_now.x = now[0] / this.webcam_element.videoWidth * CoffeeGL.Context.width;
        cur_now.y = now[1] / this.webcam_element.videoHeight * CoffeeGL.Context.height;
        prev_now.x = prev[0] / this.webcam_element.videoWidth * CoffeeGL.Context.width;
        prev_now.y = prev[1] / this.webcam_element.videoHeight * CoffeeGL.Context.height;
        dd = cur_now.dist(prev_now);
        if (dd > max_diff) {
          max_diff = dd;
          max_now.copyFrom(cur_now);
        }
      }
      if (max_diff > 6.5) {
        return this.interact(max_now.x, max_now.y);
      }
    };

    Kaliedoscope.prototype.updateActual = function(dt) {
      if (this.state["youtube"]) {
        this.t.update(this.youtube_element);
      } else if (this.state["video"]) {
        this.t.update(this.video_element);
      }
      if (this.shader != null) {
        this.shader.bind();
        this.shader.setUniform1f("uClockTick", CoffeeGL.Context.contextTime);
        this.shader.setUniform1f("uMasterAlpha", this.ready_fade_in);
      }
      if (this.shader_face != null) {
        this.shader_face.bind();
        this.shader_face.setUniform1f("uClockTick", CoffeeGL.Context.contextTime);
        this.shader_face.setUniform1f("uAlphaScalar", this.highLight.alpha_scalar);
      }
      this.naturalForce();
      if (this.mouse_pressed) {
        this.morphPlane(this.intersect, this.intersect_prev);
      }
      this.copyToFace();
      this.updateFaceHighlight(this.selected_tris);
      this.video_node.rebrew({
        position_buffer: 0,
        texcoord_buffer: 0
      });
      this.face_node.rebrew({
        position_buffer: 0,
        colour_buffer: 0
      });
      this.springBack();
      if (this.state["webcam"]) {
        this.updateWebcam(dt);
        return this.updateFader(dt);
      }
    };

    Kaliedoscope.prototype.update = function(dt) {
      if (!this.state["shaders"]) {
        return;
      }
      if (this.state["loaded"] && this.state["video"]) {
        this.ready_fade_in += (dt / 1000) / this.ready_fade_time;
        if (this.ready_fade_in > 1.0) {
          this.ready_fade_in = 1.0;
        }
        return this.updateActual(dt);
      } else {
        this.updateLoading(dt);
        return this.loading_timeout += dt / 1000;
        /*
        if @state["loaded"] and @loading_timeout > @loading_time_limit
          @state_ready = true
          credits = document.getElementById 'credits'
          credits.style.display = 'none'
        */

      }
    };

    Kaliedoscope.prototype.drawActual = function() {
      GL.clearColor(0.15, 0.15, 0.15, 1.0);
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
      this.shader.bind();
      this.shader.setUniform1i("uSamplerWebcam", 1);
      this.shader.setUniform1f("uWebcamFader", this.webcam_params.fader);
      this.video_node.draw();
      this.shader_face.bind();
      this.face_node.draw();
      if (this.webcam_node_draw) {
        this.shader_basic.bind();
        GL.disable(GL.BLEND);
        this.webcam_node.draw();
        return GL.enable(GL.BLEND);
      }
    };

    Kaliedoscope.prototype.drawLoading = function() {
      GL.clearColor(0.15, 0.15, 0.15, 1.0);
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
      if (this.shader_face != null) {
        this.shader_face.bind();
        return this.face_node.draw();
      }
    };

    Kaliedoscope.prototype.draw = function() {
      if (!this.state["shaders"]) {
        return;
      }
      if (this.state["loaded"] && this.state["video"]) {
        return this.drawActual();
      } else {
        return this.drawLoading();
      }
    };

    Kaliedoscope.prototype.resetToStart = function() {
      this.state["loaded"] = this.state["video"] = true;
      this.state["youtube"] = false;
      this.video_element.play();
      return this.youtube_element.pause();
    };

    Kaliedoscope.prototype.resize = function() {
      CoffeeGL.Context.resizeCanvas(window.innerWidth, window.innerHeight);
      this.camera.setViewport(CoffeeGL.Context.width, CoffeeGL.Context.height);
      return this.geomTrans(CoffeeGL.Context.width, CoffeeGL.Context.height);
    };

    Kaliedoscope.prototype.interact = function(x, y) {
      this.intersect_prev.copyFrom(this.intersect);
      this.rotateTexCoords();
      this.intersect.set(0, 0, 0);
      this.selected_tris_prev = this.selected_tris;
      this.selected_tris = CoffeeGL.Math.screenNodeHitTest(x, y, this.camera, this.video_node, this.intersect);
      if (this.shader != null) {
        this.shader.bind();
        if (this.selected_tris !== -1) {
          this.shader.setUniform1f("uHighLight", 1.0);
        } else {
          this.shader.setUniform1f("uHighLight", 0.0);
        }
        this.shader.setUniform3v("uMousePos", this.intersect);
      }
      if (this.shader_face != null) {
        this.shader_face.bind();
        if (this.selected_tris !== -1) {
          this.shader_face.setUniform1f("uHighLight", 1.0);
        } else {
          this.shader_face.setUniform1f("uHighLight", 0.0);
        }
        this.shader_face.setUniform3v("uMousePos", this.intersect);
        return this.shader_face.setUniform1i("uChosenIndex", this.selected_tris);
      }
    };

    Kaliedoscope.prototype.mouseMoved = function(event) {
      var x, y;
      x = event.mouseX;
      y = event.mouseY;
      return this.interact(x, y);
    };

    Kaliedoscope.prototype.mouseOver = function(event) {};

    Kaliedoscope.prototype.mouseOut = function(event) {
      return this.selected_tris_prev = this.selected_tris = -1;
    };

    Kaliedoscope.prototype.mouseDown = function(event) {
      return this.mouse_pressed = true;
    };

    Kaliedoscope.prototype.mouseUp = function(event) {
      this.mouse_pressed = false;
      this.intersect_prev.set(0, 0, 0);
      return this.intersect.set(0, 0, 0);
    };

    Kaliedoscope.prototype.shutdown = function() {
      var sound_short_triggers, video;
      sound_short_triggers = [];
      video = document.getElementById("video");
      video.pause();
      video.currentTime = 0;
      this.video_node.washup();
      this.face_node.washup();
      delete this.video_node;
      delete this.face_node;
      this.t.washup();
      delete this.t;
      this.wt.washup();
      return delete this.wt;
    };

    return Kaliedoscope;

  })();

  credits_resize = function() {
    var credits;
    credits = document.getElementById('credits');
    credits.style.left = (window.innerWidth / 2 - credits.clientWidth / 2) + 'px';
    return credits.style.top = (window.innerHeight / 2 - credits.clientHeight / 2) + 'px';
  };

  window.notSupported = function() {
    $('#webgl-canvas').remove();
    return $('#credits').append('<h3>Your browser does not support WebGL</h3><p>Visit <a href="http://get.webgl.org">get.webgl.org</a> to learn more.</p>');
  };

  canvas = document.getElementById('webgl-canvas');

  canvas.width = window.innerWidth;

  canvas.height = window.innerHeight;

  QueryString = function() {
    var arr, i, pair, query, query_string, vars, _i, _ref;
    query_string = {};
    query = window.location.search.substring(1);
    vars = query.split("&");
    for (i = _i = 0, _ref = vars.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      pair = vars[i].split("=");
      if (typeof query_string[pair[0]] === "undefined") {
        query_string[pair[0]] = pair[1];
      } else if (typeof query_string[pair[0]] === "string") {
        arr = [query_string[pair[0]], pair[1]];
        query_string[pair[0]] = arr;
      } else {
        query_string[pair[0]].push(pair[1]);
      }
    }
    return query_string;
  };

  url_vars = QueryString();

  console.log(url_vars);

  gridx = flowx = 15;

  gridy = flowy = 7;

  if (url_vars.gridx != null) {
    gridx = +url_vars.gridx;
  }

  if (url_vars.gridy != null) {
    gridy = +url_vars.gridy;
  }

  flowx = gridx;

  flowy = gridy;

  if (url_vars.flowx != null) {
    flowx = +url_vars.flowx;
  }

  if (url_vars.flowy != null) {
    flowy = +url_vars.flowy;
  }

  kk = new Kaliedoscope(gridx, gridy, flowx, flowy);

  params = {
    canvas: 'webgl-canvas',
    context: kk,
    init: kk.init,
    draw: kk.draw,
    update: kk.update,
    error: window.notSupported,
    delay_start: false,
    shutdown: kk.shutdown
  };

  kaliedoscopeWebGL = new CoffeeGL.App(params);

  keypressed = function(event) {
    var dm;
    if (event.keyCode === 119) {
      dm = document.getElementById('webcam-canvas');
      if (dm.style.display === "block") {
        dm.style.display = "none";
      } else {
        dm.style.display = "block";
      }
      dat.GUI.toggleHide();
    }
    if (event.keyCode === 102) {
      return kk.webcam_params.fade_current_time = kk.webcam_params.fade_time;
    }
  };

  if (CoffeeGL.Context.profile.browser === "Chrome") {
    item = document.getElementById("buttons");
    item.style.display = "block";
    item = document.getElementById("youtube-form");
    item.style.display = "block";
  }

  if (CoffeeGL.Context.profile.browser === "Safari") {
    item = document.getElementById("youtube-form");
    item.style.display = "block";
  }

  if (CoffeeGL.Context.profile.browser === "Firefox") {
    item = document.getElementById("firefox-warning");
    item.style.display = "block";
  }

  window.addEventListener("keypress", keypressed);

  if (typeof window !== "undefined" && window !== null) {
    window.addEventListener('resize', kk.resize, false);
  }

  if (typeof window !== "undefined" && window !== null) {
    window.addEventListener('resize', credits_resize, false);
  }

  credits_resize();

  $('#submit-button').click(function() {
    var btn, textbox;
    btn = $(this);
    btn.button('loading');
    textbox = document.getElementById("youtube-textbox");
    return kk.submitYouTube(textbox.value);
  });

  $('#camera-button').click(function() {
    var btn;
    btn = $(this);
    btn.button('youtube mode');
    return kk.webcam_params.fade_current_time = kk.webcam_params.fade_time;
  });

  $('#reset-button').click(function() {
    var btn, credits;
    btn = $(this);
    kk.resetToStart();
    credits = document.getElementById('credits');
    credits.style.display = 'block';
    return $('#submit-button').button("reset");
  });

  /*
  button.addEventListener "mouseup", (event) =>
    textbox = document.getElementById "youtube-textbox"
    textbox.disabled = 'true'
    button.button = 'loading'
    kk.submitYouTube(textbox.value)
  
  
  , false
  */


}).call(this);
